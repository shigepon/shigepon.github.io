<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: CSharp | shigeponが関心のある技術情報など]]></title>
  <link href="http://blog.shigepon.info/blog/categories/csharp/atom.xml" rel="self"/>
  <link href="http://blog.shigepon.info/"/>
  <updated>2016-01-06T12:12:22+09:00</updated>
  <id>http://blog.shigepon.info/</id>
  <author>
    <name><![CDATA[shigepon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[mono winformsがmacで文字化けする件]]></title>
    <link href="http://blog.shigepon.info/blog/2015/12/17/mono-winforms-garbled-on-mac/"/>
    <updated>2015-12-17T08:55:02+09:00</updated>
    <id>http://blog.shigepon.info/blog/2015/12/17/mono-winforms-garbled-on-mac</id>
    <content type="html"><![CDATA[<p>なでしこ2にフォームの機能入れるためにmonoのWinFormを試しているが、どうにも文字化けが治らないので、途中経過までのメモ。取りあえずボタンは文字化けしないようになった。</p>

<h2>Fontプロパティを設定する</h2>

<p><code>csharp
using System;
using System.Windows.Forms;
using System.Drawing;
...
Form win = new Form();
win.Font = new Font ("Osaka", 10);
...
</code></p>

<p>こんな感じ。</p>

<h2>~/.config/fonts.confを設定</h2>

<p>とりあえず必ず日本語フォントにするように設定してみる</p>

<p>```
<fontconfig>
<match target="pattern">
  <edit name="family" mode="assign" binding="strong"></p>

<pre><code>&lt;string&gt;Hiragino Kaku Gothic Pro W3&lt;/strong&gt;
</code></pre>

<p>  </edit>
</match>
</fontconfig>
```</p>

<p>一応どっちもメインフォームにボタン貼付けくらいなら日本語になった。でもメインフォームのタイトルが文字化けするのが治らない。メインフォームは豆腐でない文字化けなので、フォントじゃないような気がする。どうしたものか。</p>

<p>とここまで書いて、Eto.Formsっての使ってみた方が今後を考えると良いんじゃないかと思い始めたのでこれ以上やらないと思う。</p>

<p>ここまでで参考にしたページ（情報少ない）</p>

<ul>
<li><a href="http://risky-safety.org/zinnia/d/2011/09/">Zinnia hacks tomorrow.</a> 一番参考になった</li>
<li><a href="http://www.slideshare.net/babatakao/font-config">Fontconfigことはじめ</a> fontconfig回り</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[msilを手動で出力する]]></title>
    <link href="http://blog.shigepon.info/blog/2015/11/29/output-msil-manually/"/>
    <updated>2015-11-29T20:40:36+09:00</updated>
    <id>http://blog.shigepon.info/blog/2015/11/29/output-msil-manually</id>
    <content type="html"><![CDATA[<p>何個か方法がある。とりあえずは雑多にメモ書きしておく</p>

<h2>一行一行全て手動で出力する</h2>

<p>System.Refrection、System.Refrection.Emitを使ってilを直接書き出していく方法。</p>

<p>参考：
 <a href="http://stackoverflow.com/questions/15600142/reflection-emit-assemblybuilder-setentrypoint-does-not-set-entry-point">c# &ndash; Reflection.Emit: AssemblyBuilder.SetEntryPoint does not set entry point &ndash; Stack Overflow</a>ゆーてもこれそのままやっても.netは知らないけどmonoだと動かなかったりするので、修正が必要。動くコードはこちら</p>

<p>```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;
using System.Reflection.Emit;
using System.IO;
using System.Diagnostics;</p>

<p>namespace iltest
{</p>

<pre><code>class Program
{
    static void Main(string[] args)
    {
        const string ASSEMBLY_NAME = "IL_Test";
        AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly( new AssemblyName(ASSEMBLY_NAME), AssemblyBuilderAccess.Save);
        ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule(ASSEMBLY_NAME, "test.exe");
        TypeBuilder typeBuilder = moduleBuilder.DefineType("Program", TypeAttributes.Class | TypeAttributes.Public);
        MethodBuilder methodBuilder = typeBuilder.DefineMethod( "Main", MethodAttributes.HideBySig|MethodAttributes.Public | MethodAttributes.Static, typeof(void), new Type[] { typeof(string[]) });
        ILGenerator gen = methodBuilder.GetILGenerator();
        gen.Emit(OpCodes.Ldstr, "Hello, World!");
        gen.Emit(OpCodes.Call, typeof(Console).GetMethod("WriteLine", new Type[] { typeof(string) }));
        gen.Emit(OpCodes.Ldc_I4_1);
        gen.Emit(OpCodes.Call, typeof(Console).GetMethod("ReadKey", new Type[] { typeof(bool) }));
        gen.Emit (OpCodes.Pop);
        gen.Emit (OpCodes.Ret);
        typeBuilder.CreateType();
        assemblyBuilder.SetEntryPoint(methodBuilder, PEFileKinds.ConsoleApplication);
        File.Delete("test.exe");
        assemblyBuilder.Save("test.exe");
        Process.Start("test.exe");
    }
}
</code></pre>

<p>}
```</p>

<p>手順は大雑把に</p>

<ul>
<li>出力したいファイルの情報を作る。(Mainの1行目〜3行目)</li>
<li>class、メソッドを作る(4, 5行目)</li>
<li>ilを書き出す(6 〜 13行目)</li>
<li>エントリーポイントを作る(14行目)</li>
<li>ファイルを出力する(16行目)</li>
<li>実行する(17行目)</li>
</ul>


<p>OpCOdesに関してはここをチェックした<a href="https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes_fields(v=vs.110">OpCodes Fields (System.Reflection.Emit)</a>.aspx)</p>

<p>実際にどういうilコードを書けば良いかは、一回C#でビルドしたものを</p>

<p><code>sh
$ monodis hoge.exe
</code></p>

<p>みたいにしてilコードを表示させると良い</p>

<h2>一旦ビルドしたものを手動で修正する</h2>

<p>何個か選択肢があるみたいだが、<a href="http://www.mono-project.com/docs/tools+libraries/libraries/Mono.Cecil/">Mono.Cecil</a>を使ったので、Mono.Cecilについてのみ書く。</p>

<p>色々情報はあるんだけど、どうもバージョンの違いによって作法が若干変わるみたい。なので、これは2015/11/29時点の情報(バージョン0.9.6)になる。</p>

<p>test.exeにConsole.WriteLine(&ldquo;injected!&rdquo;)を追加するにはこんな感じで</p>

<p>```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Diagnostics;
using Mono.Cecil;
using Mono.Cecil.Cil;</p>

<p>namespace ceciltest{
 class Program {</p>

<pre><code>public static void Main (string[] args)
{
    asm = AssemblyDefinition.ReadAssembly(@"test.exe");
    mainDef = asm.MainModule.Types.OfType&lt;TypeDefinition&gt;().Single(t =&gt; t.Name == "MainClass");
    MethodDefinition mainMethod = mainDef.Methods.OfType&lt;MethodDefinition&gt;().Single(m =&gt; m.Name == "Main");
    Instruction ret = mainMethod.Body.Instructions.Last(i =&gt; i.OpCode == OpCodes.Ret);
    mainMethod.Body.Instructions.Remove (ret);
    mainMethod.Body.Instructions.Add (Instruction.Create(Mono.Cecil.Cil.OpCodes.Ldstr,"injected!"));
    var writeLineMethod = typeof(Console).GetMethod("WriteLine", new Type[] { typeof(string) });
    var writeLineRef = asm.MainModule.ImportReference(writeLineMethod);
    mainMethod.Body.Instructions.Add (Instruction.Create(OpCodes.Call, writeLineRef));
    mainMethod.Body.Instructions.Add (Instruction.Create(OpCodes.Ret));
    asm.Write("test.modified.exe");
}
</code></pre>

<p> }
}
```</p>

<p>大雑把にやってることはこんな感じ</p>

<ul>
<li>ビルドしたもの(dllとかexeとか)をアセンブリとして読み込む(Main関数の1行目)</li>
<li>変更したいクラス、メソッドを取り出す(2, 3行目)</li>
<li>メソッド内のilを修正(追加とか削除とか)</li>
<li>Main内に元々あるretを削除(4, 5行目)</li>
<li>出力したい文字列を設定する(6行目)</li>
<li>Console.WriteLineを定義(7行目)</li>
<li>Callする為の参照を作る(8行目)。</li>
<li>Console.WriteLineをCallする(9行目)</li>
<li>消したretを再度追加</li>
<li>修正したものを書き出し(11行目)</li>
</ul>


<h3>雑多</h3>

<ul>
<li>他の情報でImportとあるのはImportReferenceになっている</li>
<li>型やメソッドなど参照で登録するのでImportReferenceを使う。アセンブリ内で独自に定義している型の場合は別の作法が必要。</li>
</ul>


<p>参考：
+ <a href="http://mono.1490590.n4.nabble.com/TypeReference-of-bool-td1550891.html">Mono &ndash; Cecil &ndash; TypeReference of bool</a>
+ <a href="http://vx.thomazi.me/posts/net-injection-cecil/">.Net injection with Mono.Cecil(全てのメソッドを修正する例)</a></p>

<p>他参考資料</p>

<ul>
<li><a href="http://home.a00.itscom.net/hatada/_toc/dotnet.html#dotnet">.NET &amp; C#</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[なでしこ2でssl使うとthe authentication or decription has failedエラーが出る件]]></title>
    <link href="http://blog.shigepon.info/blog/2015/07/20/nadesiko2-ssl-error-the-authentication-or-decription-has-failed/"/>
    <updated>2015-07-20T20:12:34+09:00</updated>
    <id>http://blog.shigepon.info/blog/2015/07/20/nadesiko2-ssl-error-the-authentication-or-decription-has-failed</id>
    <content type="html"><![CDATA[<p>結論から言うとmonoの問題だった。</p>

<p>参考：</p>

<ul>
<li><a href="http://d.hatena.ne.jp/unarist/20110601/1306945858">MonoでSSL接続しようとしたら怒られた &ndash; うなてっくろぐ</a></li>
<li><a href="https://ramorenoc.wordpress.com/2012/12/05/the-authentication-or-decryption-has-failed-mono/">The authentication or decryption has failed – Mono | Code Adventures</a></li>
<li><a href="http://ubuntuforums.org/showthread.php?t=1841740">Problems using SSL in C#</a></li>
</ul>


<p>なでしこ2でsslにアクセスするとエラーが出る</p>

<p><code>
「https://どこかhttpsでアクセスするurl」からHTTPデータ取得してそれを表示
</code></p>

<p>エラーメッセージはこんな感じ</p>

<p><code>
[SystemError]Error getting response stream (Write: The authentication or decryption has failed.): SendFailure  at System.Net.HttpWebRequest.EndGetResponse (IAsyncResult asyncResult) [0x00000] in &lt;filename unknown&gt;:0
  at System.Net.HttpWebRequest.GetResponse () [0x00000] in &lt;filename unknown&gt;:0
  at System.Net.WebClient.GetWebResponse (System.Net.WebRequest request) [0x00000] in &lt;filename unknown&gt;:0
  at System.Net.WebClient.ReadAll (System.Net.WebRequest request, System.Object userToken) [0x00000] in &lt;filename unknown&gt;:0
  at System.Net.WebClient.DownloadDataCore (System.Uri address, System.Object userToken) [0x00000] in &lt;filename unknown&gt;:0
</code></p>

<p>調べてみると、コードで何とかなるというのがまず出て来たので、試してみたら対処出来た。C#のコードはこんな感じ</p>

<p>```c#
public Object _dataGet(INakoFuncCallInfo info)
{</p>

<pre><code>System.Net.ServicePointManager.ServerCertificateValidationCallback += (s,ce,ca,p) =&gt; true;
....
</code></pre>

<p>}
```</p>

<p>ただし、この対処だとhttpアクセスとhttpsアクセスが大差なくなるみたいなことが書いてあったので、これじゃいかんなともうちょっと調べてみると、要はmonoにルート証明書がインストールされてなかったのが原因らしかった。対処法は参考にしたページほぼそのままで</p>

<p><code>sh
$ mozroots --import --sync
</code></p>

<p>サードパーティーの認証を受入れる場合は</p>

<p><code>sh
$ certmgr -ssl https://どこかhttpsでアクセスするドメイン
</code></p>

<p>この認証本当に受入れていいの？みたいなメッセージが出たら「y」を押せばおk</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[なでしこ2のプラグインを作る方法]]></title>
    <link href="http://blog.shigepon.info/blog/2014/01/29/nadesiko2-make-plugin/"/>
    <updated>2014-01-29T09:49:17+09:00</updated>
    <id>http://blog.shigepon.info/blog/2014/01/29/nadesiko2-make-plugin</id>
    <content type="html"><![CDATA[<p>2015-12-01：情報が古くなったので古い部分を修正しました。</p>

<p>なでしこ2でプラグインを作りたい人向けというニッチすぎるネタです。現在なでしこの時期バージョンなでしこ2が開発中です(えらい長いこと開発中です)が、構文の実装がある程度終わっているので、プラグインを開発することが出来ます。try catchの実装どうするかなーとか考えて進んでないですが、それはそれ。</p>

<p>なでしこ2はC#で組まれているので、プラグインもC#で組むことができます。</p>

<h2>準備</h2>

<p><del>まずは準備として、なでしこ2のソースをsvnでチェックアウトします。 <a href="http://code.google.com/p/nadesiko2/source/checkout">URL</a></del></p>

<p>まずは準備として、なでしこ2のソースをGithubからクローンします。 ~~</p>

<p><code>sh
$ git clone https://github.com/kujirahand/nadesiko2.git
</code></p>

<p><del>SharpDevelopで開発中なので、SharpDevelopでソリューションを開きます。</del>XamarinやVisualStudioで開発出来るので、そこらへんでソリューションを開きます。</p>

<p>cnakoをビルドする必要があるので、Nako2_CNakoソリューション(Nako2_CNako.sln)を開いて、cnako2プロジェクトをビルドしておきます。cnako2/bin/Debugフォルダにcnako2.exeが出来ます。これをなでしこ2のコード実行に使います。</p>

<h2>プラグイン作成</h2>

<p>プラグイン作成には今まで作成したプラグインがNakoPluginXXXというプロジェクト名であるので、それを参考にすれば良いわけですが、軽く説明しておきます。</p>

<p>プラグインのソースは下のようになります。</p>

<p>```csharp
/<em>
 * Created by SharpDevelop.
 * User: shigepon
 * Date: 2011/04/04
 * Time: 9:42
 *
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 </em>/
using System;
using System.Collections.Generic;
using System.Text;
using Libnako.JPNCompiler;
using NakoPlugin;
namespace NakoPluginSample{</p>

<pre><code>public class NakoPluginSample : INakoPlugin    {
string _description = &amp;quot;サンプルプラグイン&amp;quot;;
    double _version = 1.0;
    //&lt;del&gt; プラグイン共通の部分 &lt;/del&gt;
    public double TargetNakoVersion { get { return 2.0; } }
    public bool Used { get; set; }
    public string Name { get { return this.GetType().FullName; } }
    public double PluginVersion { get { return _version; } }
    public string Description { get { return _description; } }
    //&lt;del&gt; 関数の定義 &lt;/del&gt;
    public void DefineFunction(INakoPluginBank bank)        {
        bank.AddFunc({関数名}&amp;cedil; {なでしこ形式の引数}&amp;cedil; {戻り値の形式}&amp;cedil; {実際の呼び出し先}&amp;cedil;{関数の説明}&amp;cedil; {関数のよみかた});
    }
// プラグインの初期化処理
    public void PluginInit(INakoInterpreter runner)        {
    }
    // プラグインの終了処理
    public void PluginFin(INakoInterpreter runner)        {
    }
   public Object {実際の処理}(INakoFuncCallInfo info){
        ...
    }
}
</code></pre>

<p>}
```</p>

<!-- more -->


<p>実装時に大事なとこを説明します。</p>

<ul>
<li>まずプラグイン共通部分とPluginInit、PluginFinはコピペでもかまわないと思います。私もまだ初期処理、終了処理の必要なプラグインは作っていません。</li>
<li>なでしこ上での関数呼び出し方法の定義はDefineFunctionで行います。bank.AddFuncメソッドで関数を追加できます。メソッド内の引数は下のように設定します。
++ 関数名はなでしこで呼び出す名前になります。（例：文字検索）なでしこで使う助詞を使わないとか、他の命令の名称とかぶらないなどの制限があります。
++ なでしこ形式の引数は「SでAを」のようになでしこで一般的に使う形式で指定します。引数を参照渡しにしたい場合は「{参照渡し}SでAを」のように指定します。助詞を複数指定したい場合は「SでAを|Sが」という形式で指定します。参照渡しを使う場合は実装が少々複雑になります。後日やり方を書こうと思います。
++ 戻り値の形式はenum NakoVarTypeで指定します。(Void&cedil; Int&cedil; Double&cedil; String&cedil; Array)
++ 実際の呼び出し先はそのままメソッド名を指定します。(_hogeとか)
++ 関数の説明と関数のよみかたは分かりやすさの為に必要です。個人用なら適当でも良いと思います。（多分今後エディタとかそういうのにつかわれると思います）</li>
<li>実際の処理は必ずINakoFuncCallInfo型のインスタンスを引数に取ります。なでしこで渡された引数はこのインスタンスから取得します。取得方法は以下</li>
</ul>


<p><code>csharp
long l = info.StackPopAsInt();
double d = info.StackPopAsDouble();
String s = info.StackPopAsString();
Object o = info.StackPop();//配列の場合はこれを使う
</code></p>

<p><del>StackPopメソッドで得られる値はNakoVariable型なので、ちょっと扱いが難しくなります。実際の処理の実装方法はまた今度</del></p>

<h2>簡単なプラグイン</h2>

<p>例として「なでしこ」という文字があったら、「なでしこ2最高！」と変換するだけの命令として「アピール」という命令を作ってみます。仕様は次のようにしてみます。</p>

<ul>
<li>引数は文字列として助詞は「を」を使う</li>
<li>引数は１つ</li>
<li>プラグイン名はNakoPluginAppealとする</li>
<li>実装用のメソッドは_appealとする</li>
</ul>


<p>Xamarinでの作成手順は次のようになります（多分VisualStudioでも似たようなもん）</p>

<ul>
<li>Nako2_Pluginsソリューション(Nako2_Plugins.slnを開く)で新しいプロジェクトとしてNakoPluginAppealという名前のC#のライブラリを作ります。（ソリューションで歯車アイコンクリック（又は右クリック））→追加→新しいプロジェクトを追加→ダイアログでC#をクリック→ライブラリを選択→名前をNakoPluginAppealとする→OK）</li>
<li>参照にNakoPluginを追加する（NakoPluginAppealの参照で歯車アイコンクリック（又は右クリック）→参照アセンブリの編集→ダイアログで.NETアセンブリタブを選択→NakoPlugin.dllをチェック、又は閲覧ボタンからNakoPlugin.dllを選ぶ→OK）</li>
<li>NakoPluginAppeal.csを編集する</li>
</ul>


<p>```csharp NakoPluginAppeal.cs
using System;
using System.Text;
using Libnako.JPNCompiler;
using NakoPlugin;
namespace NakoPluginAppeal{</p>

<pre><code>public class NakoPluginAppeal : INakoPlugin    {
string _description = &amp;quot;サンプルプラグイン&amp;quot;;
    double _version = 1.0;
    //&lt;del&gt; プラグイン共通の部分 &lt;/del&gt;
    public double TargetNakoVersion { get { return 2.0; } }
    public bool Used { get; set; }
    public string Name { get { return this.GetType().FullName; } }
    public double PluginVersion { get { return _version; } }
    public string Description { get { return _description; } }
    //&lt;del&gt; 関数の定義 &lt;/del&gt;
    public void DefineFunction(INakoPluginBank bank)        {
        bank.AddFunc("アピール", "Aを", NakoVarType.String, _appeal, "なでしこ2をアピールする", "あぴーる");
    }
// プラグインの初期化処理
    public void PluginInit(INakoInterpreter runner)        {
    }
    // プラグインの終了処理
    public void PluginFin(INakoInterpreter runner)        {
    }
    public string _appeal(INakoFuncCallInfo info){
        string fr = info.StackPopAsString();
        return fr.Replace("なでしこ", "なでしこ2最高！");
    }
}
</code></pre>

<p>}
```</p>

<ul>
<li>ビルドする</li>
<li>NakoPluginAppeal/bin/Debug/NakoPluginAppeal.dllをcnako2/bin/Debug/にコピー</li>
</ul>


<p>実行するなでしこ2のコードは次のようになります。</p>

<p><code>
A = 「なでしこ」をアピール
Aを表示
</code></p>

<ul>
<li>これをcnako2/bin/Debug/test.nakoに保存</li>
</ul>


<p>あとは下のコマンドを実行すれば結果が表示されます</p>

<p><code>sh
$ cd cnako2/bin/Debug/
$ mono cnako2.exe test.nako
なでしこ最高！
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C#で作ったdllをなでしこで使う]]></title>
    <link href="http://blog.shigepon.info/blog/2014/01/28/nadesiko-plugin-cs2/"/>
    <updated>2014-01-28T22:42:43+09:00</updated>
    <id>http://blog.shigepon.info/blog/2014/01/28/nadesiko-plugin-cs2</id>
    <content type="html"><![CDATA[<p>C#のdllを呼び出せるように、C#のdllを参照した後、Plugin.cppの一部を以下のように書き換えました</p>

<p>```
PHiValue __stdcall sample01(DWORD param) {</p>

<pre><code>PHiValue result;
ClassLibrary1::Class1::Method1();
result = nako_var_new(NULL);
hi_setStr(result&amp;cedil; &amp;quot;abc&amp;quot;&amp;cedil; sizeof(&amp;quot;abc&amp;quot;));
return result;
</code></pre>

<p>}
NAKO_API(void) ImportNakoFunction(void) {</p>

<pre><code>// ユーザー命令の追加
nako_addFunction(&amp;quot;sample01&amp;quot;&amp;cedil;&amp;quot;&amp;quot;&amp;cedil; sample01&amp;cedil; 0);
</code></pre>

<p>}
```</p>

<!-- more -->


<p>なでしこ側のソースは以下のようにして呼び出してみました</p>

<p><code>
結果=sample01
結果を言う
</code></p>

<p>これでダイアログボックスに「method1」が表示され、続いて「abc」が表示されればOKです。</p>

<p>しかし・・・結果は外部例外　E0434F4Dを出力してちゃんと動きませんでしたorz。この例外はtry&hellip;catchで掴もうとしても掴めません。どうも処理の関数（ここではsample01）に入った瞬間にエラーを返してしまうようです。ちなみにこのコードでググっても原因は理解できませんでした。ということで、クジラ飛行机氏（なでしこ作者）にメールで泣きつきました。</p>

<p>すると</p>

<blockquote><p>vnako.exe と同じフォルダに配置したらエラー出ませんでした。たぶん、plug-ins フォルダにパスを通さない限り、DLLがもう一方を参照できなくなるのだと思います。</p></blockquote>

<p>という返事が！まじで！？と思い試してみると・・・上手くいくじゃないですか！これでC#で作ったdllもなでしこで利用できるようになりました。</p>
]]></content>
  </entry>
  
</feed>
