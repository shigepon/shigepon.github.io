<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Django | shigeponが関心のある技術情報など]]></title>
  <link href="http://blog.shigepon.info/blog/categories/django/atom.xml" rel="self"/>
  <link href="http://blog.shigepon.info/"/>
  <updated>2015-07-01T10:16:41+09:00</updated>
  <id>http://blog.shigepon.info/</id>
  <author>
    <name><![CDATA[shigepon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[djangoをプロファイリングする]]></title>
    <link href="http://blog.shigepon.info/blog/2015/07/01/profiling-django/"/>
    <updated>2015-07-01T09:06:13+09:00</updated>
    <id>http://blog.shigepon.info/blog/2015/07/01/profiling-django</id>
    <content type="html"><![CDATA[<p>作ってるWebサービスが条件によってえらい重くなるので、ボトルネックを探すためにプロファイラを動かしてみようと考えてやってみたらそこそこハマった。</p>

<p>先に結論：</p>

<p><strong>Middleware使ってブラウザに表示させるのが楽だった</strong></p>

<p>条件</p>

<ul>
<li>cui環境なので、プロファイル結果は画像作るかブラウザ表示するかのどちらか</li>
<li>コードに埋めこまない形</li>
</ul>


<p>まず参考にしたのは公式ページの<a href="https://code.djangoproject.com/wiki/ProfilingDjango">ProfilingDjango – Django</a>。ざっくりとした結果が知りたかったのでrunprofileserverを試してみることにした。</p>

<h2>開発サーバでやってみる（runprofileserver）</h2>

<p>django-extensionの一機能で</p>

<p><code>sh
$ pip install django-extensions
</code></p>

<p>でインストールして、</p>

<p><code>py settings.py
INSTALLED_APP = (...
   'django_extensions',
)
</code></p>

<p>で設定して</p>

<p><code>sh
$ python manage.py runprofileserver
</code></p>

<p>とすると、よしなに/tmpフォルダ内にプロファイル結果を吐き出してくれる開発用サーバだそうで、これは便利そうと思い、やってみた。</p>

<h3>結果を画像にしようとしてハマる</h3>

<p>プロファイル結果からgraphviz通して画像にしたらブラウザから確認出来るし楽なんじゃね？とか良く考えると不毛なことを考えたのが間違いのもと。普通にKCacheGrind使ってろって話なんだけど、やってみた</p>

<p>ツールとして使ったもの</p>

<ul>
<li><a href="https://github.com/jrfonseca/gprof2dot">gprof2dot</a>、プロファイル結果をdotファイルに変換する</li>
<li>graphviz、dotファイルを画像に変換する</li>
</ul>


<p>話にならなかったもの（良く考えるとこのケースで使えないの当たり前なのに使おうとして失敗したもの）</p>

<ul>
<li>xdebugtoolkit、単純にxdebugの結果でないとそりゃ使えないよねと納得した</li>
</ul>


<p>あまり良く分かってなかったので、KCacheGrind互換で出力しておけば、色んなソフト使ってよしなに出来るんじゃね？と思ってみた。んでKCacheGrind互換出力ってcallgrind形式ってことだよね！と勝手に思い込んでた</p>

<p><code>sh
$ python manage.py runprofileserver --kcachegrind
</code></p>

<p>おもむろにdotファイルに変換!</p>

<p><code>sh
$ path/to/gprof2dot -o out.dot -f callgrind /tmp/xxx.prof
....
AssertionError
</code></p>

<p>うまくいかない。何かの計算値がこうなるはずなのにならないよ！とか怒られてる。って良く考えたらKCacheGrind互換の出力がcallgrind形式って保証がどこにもない！</p>

<p>ってことで、あれこれドキュメント読んでたら、runprofileserverはhotshot使ってるとか何とか書いてあるから、何も指定しなかったらhotshotでの形式になる・・・ってことは全然説明されてないけど-fのオプションはpstatsで良いんじゃね？</p>

<p>と勝手に予想して</p>

<p><code>sh
$ python manage.py runprofileserver
</code></p>

<p><code>sh
$ path/to/gprof2dot -o out.dot -f pstats /tmp/xxx.prof
</code></p>

<p>とやるとout.dotが出来ましたとさ。あとは色んなとこに書いてある（例えば<a href="http://stackoverflow.com/questions/9279144/interpreting-callgrind-data">ここ</a>）ように、dotファイルを画像ファイルに変換すると、ちゃんと画像が出来上がった。</p>

<p>ただ・・・・、まだ設定分かってないからだと思うんだけど、出来上がった画像にはviewやmodelのメソッドが一切書かれておらず、この情報だけからボトルネック探すのかなりキツイんじゃね？ということだけが分かった。</p>

<h3>同一ドメインのurlを内部で呼び出してハマる</h3>

<p>何故かURLによってプロファイル作るのが途中で止まって、サーバもレスポンスを返してくれなくなった。問題箇所を調べると、どうも内部で同じrunprofileserverで管理しているurlにアクセスすると止まっちゃう模様。別サーバを立てて、そこにアクセスするようにすれば、問題無く動作した。</p>

<h2>手間なのでMiddlewareでプロファイルすることにした</h2>

<p>いちいち開発中の状態なのにサーバ2つ立てて面倒だったり、結局作った画像見ても良く分からなかったので、今度はMiddlewareに埋め込むタイプを試してみた。</p>

<h3>取りあえず動かなくてハマる</h3>

<p>Extendedって書いてあるしということで<a href="https://djangosnippets.org/snippets/605/">djangosnippets: Extended Profiling Middleware</a>を試してみた。</p>

<p>手順は</p>

<ul>
<li>↑のページのファイルをダウンロード（コード右上にダウンロードボタンがある）</li>
<li>適当な名前を付けてimport出来る適当な場所に配置。（オラはmodulesってとこにprofiler.pyという名前を付けて置いてみた）</li>
<li>settings.pyにmiddlewareを登録する</li>
<li>プロファイルしたいURLにprof=というパラメータを付けてブラウザでアクセスする</li>
</ul>


<p>って感じ。settings.pyは</p>

<p>```py settings.py
MIDDLEWARE_CLASSES = (
&hellip;</p>

<pre><code>'modules.profiler.ProfileMiddleware',
</code></pre>

<p>)
```</p>

<p>こんな感じ。で、上のようにブラウザでアクセスするとエラー・・・</p>

<p><code>
AttributeError: 'WSGIRequest' object has no attribute 'has_key'
</code></p>

<p>なので、コード上で</p>

<p><code>py
request.has_key
</code></p>

<p>となっているところを</p>

<p><code>py
request.GET.has_key
</code></p>

<p>と変更すると上手く動いた。ProfileMiddlewareのページ内コメントを見ると</p>

<p><code>py
'prof' in request.GET
</code></p>

<p>と変更しても動くらしい。んで、プロファイルしたいurlにprof=をパラメータとして付けてアクセスすると、ブラウザ上に</p>

<p>```
47793 function calls (42681 primitive calls) in 0.907 seconds</p>

<p>   Ordered by: internal time, call count</p>

<p>   ncalls  tottime  percall  cumtime  percall filename:lineno(function)</p>

<pre><code>    3    0.608    0.203    0.608    0.203 /path/to/python/local/lib/python/site-packages/django/db/backends/utils.py:58(execute)
   30    0.112    0.004    0.112    0.004 /usr/lib/python/socket.py:406(readline)
   12    0.050    0.004    0.050    0.004 /usr/lib/python/socket.py:223(meth)
</code></pre>

<p>&hellip;.
```</p>

<p>という形でプロファイルが表示出来た。もーこれでいーや。ということでやったのはここまで。まだまだだけど、取りあえずプロファイル結果を出すまでだけでハマったし、次回やっても同じようにハマりそうなのでメモしておく。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django 1.6から1.7にアップデートしてみた]]></title>
    <link href="http://blog.shigepon.info/blog/2015/03/09/migrate-from-django-1-dot-6-to-1-dot-7/"/>
    <updated>2015-03-09T22:11:02+09:00</updated>
    <id>http://blog.shigepon.info/blog/2015/03/09/migrate-from-django-1-dot-6-to-1-dot-7</id>
    <content type="html"><![CDATA[<p>Djangoが去年の9月に1.7にバージョンアップしてて、今更ながらアップデートしてみた。色々教えて頂いた<a href="https://twitter.com/key3">@key3</a>さんに感謝！</p>

<p>※注　アップデートの前に必ずデータとかソースとか色々バックアップしておくこと。</p>

<h2>Django本体のアップデート</h2>

<p>Djangoはpipで管理してるので、pipコマンドでアップデート出来る</p>

<p><code>sh
$ pip install django -U
</code></p>

<!-- more -->


<p>これで本体はアップデート完了した。</p>

<!-- more -->


<h2>プロジェクトをDjango1.7で動かす</h2>

<p>何も変更せずにおもむろに</p>

<p><code>sh
$ python manage.py runserver
</code></p>

<p>とするとエラー出て動かなかった。</p>

<p><code>
raise AppRegistryNotReady("Models aren't loaded yet.")
</code></p>

<p>Tracebackを見てみるとどうもmodels.pyの中で</p>

<p><code>py models.py
admin.site.register(Model)
</code></p>

<p>とかやってたのがまずかったみたいで、管理サイトで使うモデル定義などのコードをadmin.pyに移動したら上のエラーは出なくなった。何となくで書いてたらいかんな。ちなみにアップデートには関係無いけど、Django1.7で@admin.register(Model)というデコレーターが使えるようになったので、そっちに変えた方がスマートな気がする。</p>

<p>次はSouthでマイグレーションやってるプロジェクトだったので、下のようなエラーが出た。</p>

<p><code>sh
raise RuntimeError("South does not support Django 1.7 or higher. Please use native Django migrations.")
</code></p>

<p>要はSouthはもうサポートしてないからDjango自身のマイグレーションでやってねということらしい。</p>

<p><a href="https://docs.djangoproject.com/en/1.7/topics/migrations/#upgrading-from-south">Migrations | Django documentation | Django</a>を見ながらやってみる。ざっくり手順を日本語で書いておく</p>

<ul>
<li>マイグレーションの状態がちゃんと最新になっているか確認する</li>
<li>settings.pyのINSTALLED_APPSの行から'south'を取り除く</li>
<li>数字の付いたマイグレーションファイルを全て削除する。ディレクトリと__init__.pyは残す。.pycファイルも削除すること。</li>
<li>python manage.py makemigrasionsを実行する。Djangoが空のマイグレーションディレクトリに新しい初期マイグレーションを作る。</li>
<li>python manage.py migrateを実行する。Djangoは初期マイグレーションをチェックして、実行しないで適用済みにする。</li>
</ul>


<p>以上やってみたら、エラーは出ずにプロジェクトをDjango1.7に対応できた。めでたしめでたし。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[uwsgiメモ]]></title>
    <link href="http://blog.shigepon.info/blog/2015/03/05/uwsgi-memo/"/>
    <updated>2015-03-05T10:21:54+09:00</updated>
    <id>http://blog.shigepon.info/blog/2015/03/05/uwsgi-memo</id>
    <content type="html"><![CDATA[<p>uwsgi関連ではまった点などをメモ</p>

<h2>invalid request block size</h2>

<p>ajaxでサーバ側からデータを読み込むライブラリを使ってると、条件によって502エラーが出てる(=大体djangoとかのプログラム側のエラーで出る)ので、uwsgiのログを調べると、invalid request block sizeというエラーが出てた。</p>

<p>んで、調べてみると、uwsgiがリクエストのサイズが大きすぎるとエラーを吐いているらしい。ライブラリ側で勝手にパラメーター付けて送られてリクエストのサイズが大きくなっているので、こりゃ調整しないとなということで調べてみた。起動時にオプション設定するか、iniファイルで設定したらいけるらしい</p>

<p><code>sh
$ uwsgi --buffer-size=xxxx
</code></p>

<!-- more -->


<p><code>ini
...
buffer-size= xxxx
...
</code></p>

<!-- more -->


<p>参考：<a href="http://stackoverflow.com/questions/15878176/uwsgi-invalid-request-block-size">uwsgi invalid request block size &ndash; Stack Overflow</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[djangoのModelFormでMultiWidgetを使って見る]]></title>
    <link href="http://blog.shigepon.info/blog/2015/01/24/django-modelform-multiwidget/"/>
    <updated>2015-01-24T17:23:07+09:00</updated>
    <id>http://blog.shigepon.info/blog/2015/01/24/django-modelform-multiwidget</id>
    <content type="html"><![CDATA[<p>ModelFormでModelの１つのカラムを複数のフォーム要素（inputとか）で表現したかったので調べてみた。フォーム要素を適当に作って、clean_xxxの時にくっつけるとかそんな実装の仕方も出来るみたいだけど、MultiWidgetを使うと、Modelの１つのカラムに対して複数のinput要素を使うことが出来るみたいなので、使ってみた。名前のカラムに対して姓、名の入力要素を作るとかそんなのが出来るみたい。</p>

<p>まずはMultiWidgetを継承したクラスを作る</p>

<p>```py models.py
from django.forms.widgets import MultiWidget</p>

<p>class NameWidget(MultiWidget):</p>

<p>```</p>

<p>次にクラスに対して、__init__をオーバーライドし、widgetとしてTextInputのフォームを2つ登録してみた。コードはこんな感じ。</p>

<!-- more -->


<p>```py models.py
class NameWidget(MultiWidget):</p>

<pre><code>def __init__(self,attrs=None):
    widgets = (
            forms.TextInput(attrs=attrs.update({"placeholder":"姓"})),
            forms.TextInput(attrs=attrs.update({"placeholder":"名"}))
            )
    super(NameWidget,self).__init__(widgets,attrs)
</code></pre>

<p>```</p>

<p>widgetsはリストでもタプルでも良さげ？ともかくやることはwidgetのリストかタプルを作って、親クラス(MultiWidget)のinitを呼び出すこと。</p>

<p>次に、decompress、value_from_datadictメソッドを書く。decompressはカラムの値を複数のフォームに振り分ける手順、value_from_datadictはModelFormの入力データからModelのカラムに入れる値を作る手順を記述する。姓名を半角スペースで繋げて、半角スペースで分割するように作ってみた。</p>

<p>```py models.py
class NameWidget(MultiWidget):</p>

<pre><code>def __init__(self,attrs={}):
    attrsSei = attrs.copy()
    attrsMei = attrs.copy()
    widgets = (
            forms.TextInput(attrs=attrsSei.update({"placeholder":"姓"})),
            forms.TextInput(attrs=attrsMei.update({"placeholder":"名"}))
            )
    super(NameWidget,self).__init__(widgets,attrs)
def decompress(self,value):
    if value:
        names = value.split(' ')
        return (names[0],names[1])
    return (None,None)
def value_from_datadict(self,data,files,name):
    ulist = [widget.value_from_datadict(data,files,name+'_{0}'.format(i)) for i, widget in enumerate(self.widgets)]
    return u"{0} {1}".format(ulist[0].replace(u' ',''),ulist[1].replace(u' ',''))
</code></pre>

<p>```</p>

<p>あとはこのWidgetを使いたい要素にwidgetとして指定すればおk</p>

<p>```py models.py
from django import forms
&hellip;（上のコードなど）&hellip;
class HogeForm(forms.ModelForm):</p>

<pre><code>name = forms.CharField(max_length=100,label=u'名前',widget=NameWidget())
</code></pre>

<p>```</p>

<p>このコードだと姓、名のフォームが2行に表示されている。1行にしたい場合はインライン指定とかそんなのを付けたクラスをattrsで指定して後はcssでやっちゃえばいいんじゃないかなと</p>

<p>```py models.py</p>

<pre><code>name = forms.CharField(max_length=100,label=u'名前',widget=NameWidget(attrs={"class":"inline"}))
</code></pre>

<p>```</p>

<p>とかそんな感じ</p>

<p>他にももっと細かくhtmlを記述出来るformat_outputとかあるみたいだけど、試してないので省略。なくても取りあえず出来る。</p>

<p>参考：<a href="https://docs.djangoproject.com/en/1.7/ref/forms/widgets/#django.forms.MultiWidget">Django英語ドキュメント</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pythonのデコレーターをdjangoで使って見る]]></title>
    <link href="http://blog.shigepon.info/blog/2015/01/06/python-decorator/"/>
    <updated>2015-01-06T08:55:46+09:00</updated>
    <id>http://blog.shigepon.info/blog/2015/01/06/python-decorator</id>
    <content type="html"><![CDATA[<p>pythonのデコレーターを使ってみたらとても便利だなと思ったのでメモ</p>

<p>参考にしたページを読んでいくと理解できた。要はデコレーターとして使う関数は引数に呼び出し元の関数を貰っておいて、内部で作った関数を返せば良い。内部の関数は適当に作れるみたい（今のとこそういう理解をしている）。djangoのビューで呼び出したかったので、内部の関数で可変長引数を取れるようにして下のようにしたら動いた。</p>

<p>```py
def outer(func):</p>

<pre><code>def inner(*args,**kwargs):
    print "hoge"
    return func(*args,**kwargs)
return inner
</code></pre>

<p>```</p>

<!-- more -->


<p>この時、args[0]にHttpRequestオブジェクトが入ってるので、これをいじると適当に値を追加したり整形したりするのをビューの外部に持っていけるので、使いようによっては共通部分と個別部分の分離や、ビューに直接関係ない処理（ログとか）を分離出来るので便利な感じがする。ただ、やりすぎるとコードが分割されすぎて読みにくくなる気もする。</p>

<!-- more -->


<p>```py
def outer(func):</p>

<pre><code>def inner(*args,**kwargs):
    request = args[0]
    request.hoge = "fuga"
    return func(*args,**kwargs)
return inner
</code></pre>

<p>@outer
def hoge(request):</p>

<pre><code>print request.hoge
....
</code></pre>

<p>```</p>

<p>とやったりすることが出来る。個人的にはWebサービスでサイドメニューに必要な情報をデコレーターでやって、メインコンテンツに必要な情報をビューでやるとかそんな感じで使ってみようと思う。</p>

<p>参考：<a href="http://qiita.com/_rdtr/items/d3bc1a8d4b7eb375c368">Pythonのデコレータを理解するための12Step &ndash; Qiita</a></p>
]]></content>
  </entry>
  
</feed>
