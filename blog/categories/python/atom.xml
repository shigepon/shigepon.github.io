<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | shigeponが関心のある技術情報など]]></title>
  <link href="http://blog.shigepon.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://blog.shigepon.com/"/>
  <updated>2015-03-09T11:48:14+09:00</updated>
  <id>http://blog.shigepon.com/</id>
  <author>
    <name><![CDATA[shigepon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[djangoのModelFormでMultiWidgetを使って見る]]></title>
    <link href="http://blog.shigepon.com/blog/2015/01/24/django-modelform-multiwidget/"/>
    <updated>2015-01-24T17:23:07+09:00</updated>
    <id>http://blog.shigepon.com/blog/2015/01/24/django-modelform-multiwidget</id>
    <content type="html"><![CDATA[<p>ModelFormでModelの１つのカラムを複数のフォーム要素（inputとか）で表現したかったので調べてみた。フォーム要素を適当に作って、clean_xxxの時にくっつけるとかそんな実装の仕方も出来るみたいだけど、MultiWidgetを使うと、Modelの１つのカラムに対して複数のinput要素を使うことが出来るみたいなので、使ってみた。名前のカラムに対して姓、名の入力要素を作るとかそんなのが出来るみたい。</p>

<p>まずはMultiWidgetを継承したクラスを作る</p>

<p>```py models.py
from django.forms.widgets import MultiWidget</p>

<p>class NameWidget(MultiWidget):</p>

<p>```</p>

<p>次にクラスに対して、__init__をオーバーライドし、widgetとしてTextInputのフォームを2つ登録してみた。コードはこんな感じ。</p>

<p>```py models.py
class NameWidget(MultiWidget):</p>

<pre><code>def __init__(self,attrs=None):
    widgets = (
            forms.TextInput(attrs=attrs.update({"placeholder":"姓"})),
            forms.TextInput(attrs=attrs.update({"placeholder":"名"}))
            )
    super(NameWidget,self).__init__(widgets,attrs)
</code></pre>

<p>```</p>

<p>widgetsはリストでもタプルでも良さげ？ともかくやることはwidgetのリストかタプルを作って、親クラス(MultiWidget)のinitを呼び出すこと。</p>

<p>次に、decompress、value_from_datadictメソッドを書く。decompressはカラムの値を複数のフォームに振り分ける手順、value_from_datadictはModelFormの入力データからModelのカラムに入れる値を作る手順を記述する。姓名を半角スペースで繋げて、半角スペースで分割するように作ってみた。</p>

<p>```py models.py
class NameWidget(MultiWidget):</p>

<pre><code>def __init__(self,attrs={}):
    attrsSei = attrs.copy()
    attrsMei = attrs.copy()
    widgets = (
            forms.TextInput(attrs=attrsSei.update({"placeholder":"姓"})),
            forms.TextInput(attrs=attrsMei.update({"placeholder":"名"}))
            )
    super(NameWidget,self).__init__(widgets,attrs)
def decompress(self,value):
    if value:
        names = value.split(' ')
        return (names[0],names[1])
    return (None,None)
def value_from_datadict(self,data,files,name):
    ulist = [widget.value_from_datadict(data,files,name+'_{0}'.format(i)) for i, widget in enumerate(self.widgets)]
    return u"{0} {1}".format(ulist[0].replace(u' ',''),ulist[1].replace(u' ',''))
</code></pre>

<p>```</p>

<p>あとはこのWidgetを使いたい要素にwidgetとして指定すればおk</p>

<p>```py models.py
from django import forms
&hellip;（上のコードなど）&hellip;
class HogeForm(forms.ModelForm):</p>

<pre><code>name = forms.CharField(max_length=100,label=u'名前',widget=NameWidget())
</code></pre>

<p>```</p>

<p>このコードだと姓、名のフォームが2行に表示されている。1行にしたい場合はインライン指定とかそんなのを付けたクラスをattrsで指定して後はcssでやっちゃえばいいんじゃないかなと</p>

<p>```py models.py</p>

<pre><code>name = forms.CharField(max_length=100,label=u'名前',widget=NameWidget(attrs={"class":"inline"}))
</code></pre>

<p>```</p>

<p>とかそんな感じ</p>

<p>他にももっと細かくhtmlを記述出来るformat_outputとかあるみたいだけど、試してないので省略。なくても取りあえず出来る。</p>

<p>参考：<a href="https://docs.djangoproject.com/en/1.7/ref/forms/widgets/#django.forms.MultiWidget">Django英語ドキュメント</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pythonのデコレーターをdjangoで使って見る]]></title>
    <link href="http://blog.shigepon.com/blog/2015/01/06/python-decorator/"/>
    <updated>2015-01-06T08:55:46+09:00</updated>
    <id>http://blog.shigepon.com/blog/2015/01/06/python-decorator</id>
    <content type="html"><![CDATA[<p>pythonのデコレーターを使ってみたらとても便利だなと思ったのでメモ</p>

<p>参考にしたページを読んでいくと理解できた。要はデコレーターとして使う関数は引数に呼び出し元の関数を貰っておいて、内部で作った関数を返せば良い。内部の関数は適当に作れるみたい（今のとこそういう理解をしている）。djangoのビューで呼び出したかったので、内部の関数で可変長引数を取れるようにして下のようにしたら動いた。</p>

<p>```py
def outer(func):</p>

<pre><code>def inner(*args,**kwargs):
    print "hoge"
    return func(*args,**kwargs)
return inner
</code></pre>

<p>```</p>

<p>この時、args[0]にHttpRequestオブジェクトが入ってるので、これをいじると適当に値を追加したり整形したりするのをビューの外部に持っていけるので、使いようによっては共通部分と個別部分の分離や、ビューに直接関係ない処理（ログとか）を分離出来るので便利な感じがする。ただ、やりすぎるとコードが分割されすぎて読みにくくなる気もする。</p>

<p>```py
def outer(func):</p>

<pre><code>def inner(*args,**kwargs):
    request = args[0]
    request.hoge = "fuga"
    return func(*args,**kwargs)
return inner
</code></pre>

<p>@outer
def hoge(request):</p>

<pre><code>print request.hoge
....
</code></pre>

<p>```</p>

<p>とやったりすることが出来る。個人的にはWebサービスでサイドメニューに必要な情報をデコレーターでやって、メインコンテンツに必要な情報をビューでやるとかそんな感じで使ってみようと思う。</p>

<p>参考：<a href="http://qiita.com/_rdtr/items/d3bc1a8d4b7eb375c368">Pythonのデコレータを理解するための12Step &ndash; Qiita</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Southをすでにあるプロジェクトに適用する]]></title>
    <link href="http://blog.shigepon.com/blog/2014/11/30/use-south-to-existing-project/"/>
    <updated>2014-11-30T23:19:26+09:00</updated>
    <id>http://blog.shigepon.com/blog/2014/11/30/use-south-to-existing-project</id>
    <content type="html"><![CDATA[<p>Southってのを使うとモデルを変更した時に、サクッとDB(PostgreSQL)に反映出来るらしんだけど、今すでに作成中のプロジェクトに反映させたかったので、メモ</p>

<h2>インストール</h2>

<p><code>sh
$ pip install south
</code></p>

<h2>設定</h2>

<p>```py settings.py
INSTALLED_APPS = (
&hellip;.</p>

<pre><code>'south',
</code></pre>

<p>)
```</p>

<h2>作成中のアプリをsouthに追加</h2>

<p>データベースが関連しているモデルが作成されているアプリにコマンドを実行すればおk</p>

<p><code>sh
$ python manage.py schemamigration アプリ名 --init
$ python manage.py syncdb --all
$ python manage.py migrate アプリ名 --fake
</code></p>

<p>syncdbしないでmigrateすると、PostgreSQLだとエラーが出たので、先にsyncdbするのが必要みたい</p>

<p>実際にモデル変更した時の作業を追記</p>

<h2>モデル変更</h2>

<p>モデルを変更したら次のコマンドでデータベースに反映する</p>

<p><code>sh
$ python manage.py schemamigration アプリ名 --auto
$ python manage.py migrate アプリ名
</code></p>

<p>この時にデータベース内の値が変更した制約等に引っ掛かる場合は途中で止まったりするので、制約に合うようにデータを変更するとか修正する。</p>

<p>参考：<a href="http://yu-write.blogspot.jp/2014/01/django-south.html">Yura YuWrite: [django] 既存のプロジェクトにsouthを追加する方法</a>、<a href="http://stackoverflow.com/questions/22236029/trouble-getting-django-set-up-on-heroku-using-south-keep-getting-programminger">postgresql &ndash; Trouble getting Django set up on Heroku using South &ndash; keep getting ProgrammingError: relation does not exist &ndash; Stack Overflow</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[djangoで国際化やってみた]]></title>
    <link href="http://blog.shigepon.com/blog/2014/11/27/django-locale/"/>
    <updated>2014-11-27T13:02:12+09:00</updated>
    <id>http://blog.shigepon.com/blog/2014/11/27/django-locale</id>
    <content type="html"><![CDATA[<p>Djangoで他の人が作ったモジュールを使ってると、英語のメッセージが入ってることがあるので、日本語化してみた。とりあえず英語のメッセージを日本語に変換するとこまで。</p>

<h2>準備</h2>

<p>gettextが無かったらインストール。Ubuntuの場合</p>

<p><code>sh
$ sudo aptitude install gettext
</code></p>

<p>プロジェクトにlocaleフォルダを作る。無いと後のコマンドでエラーが出た</p>

<h2>poファイル作成</h2>

<p>おもむろにpoファイルを作るコマンドを実行</p>

<p><code>sh
django-admin.py makemessages -l ja
</code></p>

<p>するとpath/to/locale/ja/LC_MESSAGES/django.poってファイルが出来るので、それを修正していく。ただ、このコマンドプロジェクト内だけ捜査してファイルを作るみたいで、外部モジュールの場合、上手く読み取ってくれなかった。</p>

<p>今回はvirtualenvでpipしたdjango-allauthのテンプレートを日本語化したかったので、path/to/virtualenv/dir/lib/python2.7/site-packages/allauth/templates/account/内のファイルを全部path/to/project/templates/account/にコピーしてからコマンド実行すると上手く読み取ってくれた。</p>

<h2>翻訳</h2>

<p>出来たpoファイルを編集すればオッケー。ファイル内でmsgid以下に書いてあるのが元の文、その次のmsgstr以下に文章書くと、翻訳文になる。元の英文に何かパラメーター付いてる場合は必ずパラメーターを翻訳文に設定しないとエラーが出る。</p>

<p>```py 例</p>

<h1>: path/to/python/module.py:23</h1>

<p>msgid &ldquo;Welcome to my site.&rdquo;
msgstr &ldquo;いらっしゃーい&rdquo;
```</p>

<h2>moファイル作成</h2>

<p>おもむろにコマンドを実行するとmoファイルが出来る</p>

<p><code>sh
django-admin.py compilemessages
</code></p>

<h2>settings.pyの設定</h2>

<p>これだけで動くと思ったら動かなかったので色々調べてみたらLOCALE_PATHSを設定しないといけなかった。</p>

<p>```py settings.py
LOCALE_PATHS = (</p>

<pre><code>"path/to/locale",
</code></pre>

<p>)
```</p>

<p>これ設定しておいたらちゃんと動いた。</p>

<p>あとは普通にrunserverとかでサーバ起動したら翻訳されてる</p>

<p>参考：<a href="http://docs.djangoproject.jp/en/latest/topics/i18n/translation.html">翻訳 — Django 1.4 documentation</a></p>

<p>翻訳したい文字列をマークする方法とかはリンク見れば分かる。あと、使いたい言語を選択出来るようにするとかそういう場合はLocaleMiddlewareを使うとかなんとかあるみたいだけどやってない。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[django-allauthを使ってみた]]></title>
    <link href="http://blog.shigepon.com/blog/2014/11/25/use-django-allauth/"/>
    <updated>2014-11-25T14:55:16+09:00</updated>
    <id>http://blog.shigepon.com/blog/2014/11/25/use-django-allauth</id>
    <content type="html"><![CDATA[<p>ソーシャルログインだけでなく、通常のログインもやりたかったので、django-allauthを試してみた。</p>

<h2>インストール</h2>

<p>pipで</p>

<p><code>sh
pip install django-allauth
</code></p>

<h2>ファイルでの設定</h2>

<p>settings.pyとurls.pyを設定</p>

<p>```py settings.py
INSTALLED_APPS = (
&hellip;</p>

<pre><code>'allauth',
'allauth.account',
'allauth.socialaccount',
'allauth.socialaccount.providers.twitter', #例としてTwitter
</code></pre>

<p>)
AUTHENTICATION_BACKENDS = (
&hellip;</p>

<pre><code>'allauth.account.auth_backends.AuthenticationBackend',
</code></pre>

<p>)
TEMPLATE_CONTEXT_PROCESSORS = (
&hellip;</p>

<pre><code>"django.core.context_processors.request",
"django.contrib.auth.context_processors.auth",
"allauth.account.context_processors.account",
"allauth.socialaccount.context_processors.socialaccount",
</code></pre>

<p>)
SITE_ID = 1
```</p>

<p>`&ldquo;py urls.py
urlpatterns = patterns(&rdquo;,</p>

<pre><code>...
url('^accounts/', include('allauth.urls')),
url('^accounts/profile/?', include('profile.urls',namespace='profile')), #ログイン後のリダイレクト先
</code></pre>

<p>)
```</p>

<h2>adminページでの設定</h2>

<p>ソーシャルログインする場合のみ必要。 <a href="http://domain/admin/">http://domain/admin/</a> にアクセスして管理者ログインしてSocial applicationを追加する。
フォーム内では名前を適当に付けて、Twitterの場合Client idにConsumer keyを登録して、Secret keyにConsumer secretを登録すればおk
最後に、利用可能サイトから一番上のサイト(SITE_ID=1と指定してるので)を選択するとおk</p>

<p><a href="http://domain/accounts">http://domain/accounts</a> にアクセスすればログインフォームが出てくる。出来た。</p>

<h2>テンプレートを上書きする</h2>

<p>プロジェクトディレクトリ/templates/account以下にファイルを設定すればおk
例えばログインのテンプレートなら、login.htmlを設置すればおk</p>

<p>元のファイルはgithubを見れば分かる</p>

<h2>使える機能</h2>

<p><a href="https://github.com/pennersr/django-allauth/blob/master/allauth/account/urls.py">githubのコード</a>
見れば大体分かる感じ</p>

<h2>ユーザー登録時のメール確認後の処理でハマる</h2>

<p>ユーザー登録すると通常は登録したメールアドレスにメールが届いて、そこに書いてあるURLにアクセスすると登録完了する手順が表示される。そこらへんの文章とかも上のテンプレート上書きでいけて問題ないんだけど、初期状態では登録が最後まで完了すると、そのままログインしてログイン時のリダイレクト先に移動してしまう。完了画面を表示したい場合はこれではまずい。</p>

<p>ので、<a href="http://django-allauth.readthedocs.org/en/latest/advanced.html">ここらへん</a>のCustom Redirectsの項目を参考にしてアダプタを作ってみた</p>

<p><code>py settings.py
ACCOUNT_ADAPTER = 'project.users.adapter.MyAccountAdapter'
</code></p>

<p>```py project/users/adapter.py
from django.conf import settings
from allauth.account.adapter import DefaultAccountAdapter</p>

<p>class MyAccountAdapter(DefaultAccountAdapter):</p>

<pre><code>def get_email_confirmation_redirect_url(self,request):
    path = "/account/complete"
    return path
</code></pre>

<p>```</p>

<p>でもこれだけでは上手くいかなかった。普通にログイン時のリダイレクト先に移動してしまった。どうもACCOUNT_LOGIN_ON_EMAIL_CONFIRMATIONをFalseにしないとダメみたい</p>

<p><code>py settings.py
ACCOUNT_LOGIN_ON_EMAIL_CONFIRMATION = False
</code></p>

<p>これでやっと/account/completeにリダイレクトしてくれた。ログインした状態ではダメみたいなので、ログインは再度やってもらわないといけない。うーん今のとこ仕方ないか・・・。</p>

<h2>django-allauthのサインアップフォームをカスタマイズしたい</h2>

<h3>あるフィールドにhelp_textを付ける</h3>

<p>参考：<a href="http://stackoverflow.com/questions/23580771/overwrite-django-allauth-form-field">Overwrite django-allauth form field &ndash; Stack Overflow</a></p>

<p>__init__を上書きして、フィールドに属性を追加する
コードはこんな感じ。例としてユーザー名入力フォームにヘルプテキストとして「required」という文字を追加する</p>

<p>```py appname/forms.py
from django import forms</p>

<p>class SignupForm(forms.Form):
  def <strong>init</strong>(self, *args, **kwargs):</p>

<pre><code>super(SignupForm, self).__init__(*args, **kwargs)
self.fields['username'].help_text = "required"
</code></pre>

<p>```</p>

<p><code>py settings.py
ACCOUNT_SIGNUP_FORM_CLASS = "appname.forms.SignupForm"
</code></p>

<p>こんな感じ</p>

<h3>フィールドのバリデーションを追加</h3>

<p>参考：<a href="http://stackoverflow.com/questions/24175228/how-to-clean-username-with-django-allauth-adapter">python &ndash; How to clean username with Django allauth adapter? &ndash; Stack Overflow</a></p>

<p>Account Adapterを設定してあげて、そこでclean_xxxを作ると上手くいくみたい</p>

<p><code>
</code>py project/users/adapter.py
class MyAccountAdapter(DefaultAccountAdapter):</p>

<pre><code>...
def clean_username(self, username):
    " 適当に処理を入れる
    " エラーの場合はraise Exception
    return username
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
