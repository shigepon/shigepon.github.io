<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | shigeponが関心のある技術情報など]]></title>
  <link href="http://blog.shigepon.info/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://blog.shigepon.info/"/>
  <updated>2016-01-15T12:03:06+09:00</updated>
  <id>http://blog.shigepon.info/</id>
  <author>
    <name><![CDATA[shigepon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[use groonga for django cache]]></title>
    <link href="http://blog.shigepon.info/blog/2016/01/15/use-groonga-for-django-cache/"/>
    <updated>2016-01-15T01:43:58+09:00</updated>
    <id>http://blog.shigepon.info/blog/2016/01/15/use-groonga-for-django-cache</id>
    <content type="html"><![CDATA[<p>djangoのキャッシュバックエンドとして、Redisを使ってみたけど、慣れてないし、しばらくしたらメモリを圧迫したせいかdjangoがタイムアウトを連発しだしたので、こりゃだめだと思い、<a href="http://groonga.org/ja/">groonga</a>を試してみた流れを書いておく。groongaは全文検索エンジンだけど、kvsみたいな使い方も出来る。詳しくはgroongaのページを読めば分かる、はず。</p>

<h2>groonga側の設定</h2>

<p>どうも<a href="http://groonga.org/ja/docs/server/memcached.html">Memcachedバイナリプロトコルが使える</a>らしい。マニュアルのページからおもむろに</p>

<p><code>sh
$ groonga -d --protocol memcached hoge
</code></p>

<p>とやるとhogeというファイルが出来た（hogeがデータベース名かつファイル名）。んで、</p>

<p>```sh
$ groonga -c</p>

<blockquote><p>table_list
```</p></blockquote>

<p>とするとテーブルが無い。出来てない。これじゃアクセス出来ないんじゃね？と思い（間違ってたんだけど）ググると固定のテーブル名、カラム名になってうんたらかんたらと書いていた。</p>

<p>そこで「決まった名前でテーブルを手動で作らないといけない」と思い込み、指定するべきテーブル名をググってBingして探して1時間以上、ソースからやっとテーブル名がMemcacheで・・・と分かった時点で<strong>テーブル、カラムはgroonga側で自動で作成する</strong>ことに気づいた。どうもバイナリプロトコルでアクセスがあった瞬間にテーブル、カラムを作るみたい。なので、上のコマンドだけで良かったみたい。えーそうなのー＞＜。こんな簡単なのになんでハマったのか・・・＞＜</p>

<p>ちなみにこのコマンドの場合、ポートは10041となる。</p>

<h2>django側の設定</h2>

<p>groonga側の設定でハマった理由はdjangoのキャッシュフレームワークでdjango.core.cache.backends.memcached.MemcachedCacheを使うと全然キャッシュしてくれなかったことにある。</p>

<p>このライブラリが<strong>バイナリプロトコルを使っていない</strong>というのに全く気付かず、絶対groonga側でテーブル作ってないからだと勘違いして1時間以上無駄にしてしまった。</p>

<p>で、結論としては<a href="https://github.com/jaysonsantos/django-bmemcached">Django-BMemcached</a>を使えば問題なくキャッシュしてくれる。他にもバイナリプロトコルを使うライブラリに<a href="https://github.com/django-pylibmc/django-pylibmc">django-pylibmc</a>があるけど、これは何故か接続の段階で止まってしまった。</p>

<p>手順としてはこんな感じ</p>

<p><code>sh
$ sudo aptitude install libmemcached-dev
$ pip install django-bmemcached
</code></p>

<p>aptitudeの部分は要らないかも（django-pylibmcを入れる時に怒られて入れたので、もしかして必要無いかもしれない）</p>

<p>```py settings.py
CACHES = {</p>

<pre><code>'default':{
    'BACKEND':'django_bmemcached.memcached.BMemcached',
    'LOCATION': ['127.0.0.1:10041'],
}
</code></pre>

<p>}
```</p>

<p>これはローカルで上のような形でgroongaのサーバを作った場合の設定。
これで普通のキャッシュを扱うプログラム書けばちゃんとデータをgroongaに入れてくれた。</p>

<p>めでたしめでたし。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[virtualenv上のpythonでmecabを使う (ubuntu1 12.04)]]></title>
    <link href="http://blog.shigepon.info/blog/2015/11/02/use-mecab-in-python-virtualenv-ubuntu1-12-dot-04/"/>
    <updated>2015-11-02T17:28:17+09:00</updated>
    <id>http://blog.shigepon.info/blog/2015/11/02/use-mecab-in-python-virtualenv-ubuntu1-12-dot-04</id>
    <content type="html"><![CDATA[<p>ubuntu 12.04でapt使ってmecabをインストールしている状態、virtualenvのpythonに切り替えているところからスタート</p>

<h2>先に結論</h2>

<p>mecabをソースからインストールして最新版にして、natto-pyをpipでインストールすれば出来た。</p>

<h2>1. mecab-pythonをvirtualenv上で使用してみる</h2>

<p>ファイルにmecab-pythonを置いてる場所を指定して、pip使えば良い</p>

<p><code>sh requirements.txt
https://mecab.googlecode.com/files/mecab-python-0.996.tar.gz
</code></p>

<p><code>sh
$ pip install -r requirements.txt
</code></p>

<p>これでvirtualenv上にmecab-pythonをインストール出来た。
参考：<a href="http://qiita.com/hagino3000/items/4cb73fb53537c0714044">travisでpython-mecabを動かしたい時の設定 &ndash; Qiita</a></p>

<p>でもこれでおもむろに</p>

<p><code>py
import MeCab
m = MeCab.Tagger('-Ochasen')
print '今日は良い天気'
</code></p>

<p>エラーが出たorz</p>

<h2>2. natto-pyを使ってみる</h2>

<p>pip search mecabで調べて、その後ググると、natto-pyってのがmecab使えるライブラリであるっぽいのでインストールしてみた</p>

<p>参考：<a href="https://github.com/buruzaemon/natto-py">buruzaemon/natto-py</a></p>

<p><code>sh
$ pip install natto-py
</code></p>

<p>これだけでインストール出来た。使ってみたらインストールしてあるmecabのバージョンが古過ぎて使えないと怒られたorz。</p>

<h2>3. mecabを最新バージョンにする</h2>

<p>仕方ないので</p>

<h3>aptのmecabをアンインストール</h3>

<p><code>sh
$ sudo aptitude remove mecab
</code></p>

<h3>mecabをソースからインストール</h3>

<p><code>sh
$ wget https://drive.google.com/uc?export=download&amp;id=0B4y35FiV1wh7cENtOXlicTFaRUE
$ tar zxvf mecab-0.996.tar.gz
$ cd mecab-0.996
$ ./configure
$ make
$ make check
$ sudo make install
</code></p>

<h3>mecab辞書のインストール</h3>

<p><code>sh
$ wget https://drive.google.com/uc?export=download&amp;id=0B4y35FiV1wh7MWVlSDBCSXZMTXM
$ tar zvxf mecab-ipadic-2.7.0-20070801.tar.gz
$ cd mecab-ipadic-2.7.0-20070801
$ ./configure --with-charset=utf8
$ make
$ sudo make install
</code></p>

<p>urlはそれぞれ<a href="http://taku910.github.io/mecab/#download">mecabのページ</a>からリンクされているものを用いた。</p>

<p>参考：<a href="http://tatsuyaoiw.hatenablog.com/entry/20120414/1334397985">MeCabのインストール方法 &ndash; tatsuyaoiw.hatenablog.com</a></p>

<h2>natto-pyを改めて使う</h2>

<p>```py</p>

<h1>coding: utf-8↲</h1>

<p>from natto import MeCab
nm = MeCab()
print nm.parse(&lsquo;ピンチの時には必ずヒーローが現れる。&rsquo;)</p>

<h1>MeCab result as a single string</h1>

<p>ピンチ    名詞,一般,<em>,</em>,<em>,</em>,ピンチ,ピンチ,ピンチ
の      助詞,連体化,<em>,</em>,<em>,</em>,の,ノ,ノ
時      名詞,非自立,副詞可能,<em>,</em>,<em>,時,トキ,トキ
に      助詞,格助詞,一般,</em>,<em>,</em>,に,ニ,ニ
は      助詞,係助詞,<em>,</em>,<em>,</em>,は,ハ,ワ
必ず    副詞,助詞類接続,<em>,</em>,<em>,</em>,必ず,カナラズ,カナラズ
ヒーロー  名詞,一般,<em>,</em>,<em>,</em>,ヒーロー,ヒーロー,ヒーロー
が      助詞,格助詞,一般,<em>,</em>,<em>,が,ガ,ガ
現れる  動詞,自立,</em>,<em>,一段,基本形,現れる,アラワレル,アラワレル
。      記号,句点,</em>,<em>,</em>,*,。,。,。
EOS
```</p>

<p>うまくいった。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django 1.7から1.8にアップデートしてみた]]></title>
    <link href="http://blog.shigepon.info/blog/2015/08/25/migrate-from-django-1-dot-7-to-1-dot-8/"/>
    <updated>2015-08-25T15:39:02+09:00</updated>
    <id>http://blog.shigepon.info/blog/2015/08/25/migrate-from-django-1-dot-7-to-1-dot-8</id>
    <content type="html"><![CDATA[<p><a href="http://blog.shigepon.info/blog/2015/03/09/migrate-from-django-1-dot-6-to-1-dot-7/">1.6の時</a>と同様にpipでアップデートした。</p>

<h2>注意点</h2>

<p>個人的に作っているアプリでアップデートした際にコード変更が必要だった点は以下の通り。他にも色々使えなくなった命令とかあるみたいだけど引っ掛からなかったので省略。詳しくは<a href="https://docs.djangoproject.com/en/1.8/releases/1.8/#features-removed-in-1-8">Django 1.8 release notes | Django documentation | Django</a>で見ることが出来る。</p>

<h3>urls.pyで指定するnamespace</h3>

<p>urls.pyでapp_nameを指定した場合に必ずnamespaceを指定する必要があるようになった。</p>

<p><code>py urls.py
url(r'^', include('hoge.urls',app_name='hoge')),#これはダメ
url(r'^', include('hoge.urls',app_name='hoge',namespace='hoge')),#これはOK
</code></p>

<p>ダメなコード実装してた場合は、reverseでurlを作ってる箇所にも修正が必要になる。</p>

<h3>transactionについて</h3>

<p>```py
transaction.commit_unless_managed()</p>

<p>みたいなメソッドが無くなってた。</p>

<h2>migrate関連でのハマりポイント（2015-10-20追記）</h2>

<p>1.7から1.8にバージョンアップすると、マイグレーションでエラーが出る。普通に</p>

<p><code>sh
$ python manage.py makemigrations
$ python manage.py migrate
</code></p>

<p>とするとmigrateコマンドで</p>

<p><code>sh
Error creating new content types. Please make sure contenttypes
</code></p>

<p>というメッセージが出てコマンドが途中で終わってしまう。調べて結果データベース上で</p>

<p><code>
ALTER TABLE django_content_type DROP COLUMN name;
</code></p>

<p>を実行することで対処できた。要はカラムが一個要らなくなったみたい。</p>

<p>参考：<a href="http://stackoverflow.com/questions/29917442/error-creating-new-content-types-please-make-sure-contenttypes-is-migrated-befo">django &ndash; Error creating new content types. Please make sure contenttypes is migrated before trying to migrate apps individually &ndash; Stack Overflow</a></p>

<h2>adminでユーザー追加するとnot null制限に引っ掛かるエラー（2015-10-26追記）</h2>

<p>```
admin画面でユーザーを追加すると「last_loginがnot null制限あるのにnullを入れようとした」と怒られた。</p>

<p>対策をググると普通にmigrateコマンドすればおkと書いてあるのに出来なかったのでsqlで対応してみた</p>

<p><code>
alter table auth_user alter column last_login drop not null;
</code></p>

<p>これでユーザー追加出来るようになった</p>

<h2>嬉しい点</h2>

<p>色々あるみたいだけど、PostgreSQLを使っているので、特にPostgreSQL使ってる場合に、独自のフィールドを使えるようになった点が嬉しい。ArrayFieldとか、わざわざリレーション作りたくない時とか便利そう。</p>

<p><a href="https://docs.djangoproject.com/en/1.8/ref/contrib/postgres/fields/">Djangoドキュメントによる説明</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Djangoで作成済みテーブルに手動でリレーションを追加する]]></title>
    <link href="http://blog.shigepon.info/blog/2015/07/30/add-relation-to-existing-table-using-django/"/>
    <updated>2015-07-30T10:46:15+09:00</updated>
    <id>http://blog.shigepon.info/blog/2015/07/30/add-relation-to-existing-table-using-django</id>
    <content type="html"><![CDATA[<p>リレーションの理解が悪くて酷いコードを組んでいて、それを直した話。</p>

<p>article</p>

<table>
<thead>
<tr>
<th></th>
<th align="left">key</th>
<th align="right">title</th>
<th align="right">content</th>
<th align="right">author_key</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left">1</td>
<td align="right">DjangoでHello World作ってみた</td>
<td align="right">出来なかった！</td>
<td align="right">1|</td>
</tr>
</tbody>
</table>


<p>author</p>

<table>
<thead>
<tr>
<th></th>
<th align="left">key</th>
<th align="right">name</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left">1</td>
<td align="right">shigepon|</td>
</tr>
</tbody>
</table>


<p>こんなテーブルがあって、author.keyとarticle.author_keyが繋がっている場合に
ArticleモデルをDjango使い始めの時はこんな風に作ってた</p>

<p>```py models.py
class Article(models.Model):</p>

<pre><code>key=models.IntegerField(primary_key=True)
title=models.TextField()
content=models.TextField()
author_key=models.IntegerField()
def author(self):
    return Author.objects.get(key=self.author_key)
</code></pre>

<p>class Author(models.Model):</p>

<pre><code>key=models.IntegerField(primary_key=True)
name=models.TextField()
</code></pre>

<p>```</p>

<p>いやー改めて見ると酷い。Articleを100個読み込んで、そのAuthorを出力するだけで、100回以上dbにアクセスしないといけない。という訳でこの酷いコードからリレーションを貼って、さらにdbアクセスが少なくなるように修正したらこうなった</p>

<p>参考：</p>

<ul>
<li><a href="https://docs.djangoproject.com/en/1.8/ref/models/fields/">Model field reference | Django documentation | Django</a></li>
<li><a href="https://docs.djangoproject.com/en/1.8/ref/models/querysets/">QuerySet API reference | Django documentation | Django</a></li>
</ul>


<p>```py models.py
class Article(models.Model):</p>

<pre><code>key=models.IntegerField(primary_key=True)
title=models.TextField()
content=models.TextField()
author=models.ForeignKey('Author', db_column='author_key', to_field='key', related_name='articles')
</code></pre>

<p>class Author(models.Model):</p>

<pre><code>key=models.IntegerField(primary_key=True)
name=models.TextField()
</code></pre>

<p>```</p>

<p>こんな感じで適切にForeignKeyフィールドを設定することで、上の構成のテーブルにもリレーションを貼ることが出来た。db_columnでArticle側のリレーションキーになるカラムを指定して、to_fieldでAuthor側のリレーションキーになるカラムを指定する。related_nameは指定しないとエラーが出た。</p>

<p>んで、dbアクセスがなるべく少なくなるように（sqlでjoinを組んでくれるように）views.pyを書いてみると</p>

<p>```py views.py
from app.models import Article
def index(request):</p>

<pre><code>articles = Article.objects.select_related('author').all()
...
</code></pre>

<p>```</p>

<p>みたいにselect_relatedメソッドを使うとjoinしてくれた。prefetch_relatedってメソッドでも同じように出来る（ちょっと役割は違う）らしいが試していない。ざっくりドキュメントを読むと、ForeignKeyと１対１リレーションにはselect_relatedが良く、Many to ManyやMany to Oneにはprefetch_relatedが良いらしい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DjangoモデルをDjangoプロジェクトの外から使う]]></title>
    <link href="http://blog.shigepon.info/blog/2015/07/28/use-django-model-outside-django-project/"/>
    <updated>2015-07-28T16:43:55+09:00</updated>
    <id>http://blog.shigepon.info/blog/2015/07/28/use-django-model-outside-django-project</id>
    <content type="html"><![CDATA[<p>参考：</p>

<ul>
<li><a href="http://d.hatena.ne.jp/shobonengine/20120103/1325535420">外部から Django プロジェクトのデータベースを操作する &ndash; ShobonEngineの日記</a></li>
<li><a href="http://stackoverflow.com/questions/25537905/django-1-7-throws-django-core-exceptions-appregistrynotready-models-arent-load">python &ndash; Django 1.7 throws django.core.exceptions.AppRegistryNotReady: Models aren&rsquo;t loaded yet &ndash; Stack Overflow</a></li>
</ul>


<p>モデルインポート前に以下の手順が必要</p>

<ul>
<li>プロジェクトをsys.pathに追加</li>
<li>DJANGO_SETTINGS_MODULE環境変数がプロジェクトのsettings.pyを指すように指定</li>
<li>applicationのロードが必要? (上2つだけだとModels aren&rsquo;t loaded yetというエラーが出た)</li>
</ul>


<p>sys.pathにはフルパスを入れれば確実。必要なコードは下のような感じになる。</p>

<p>```py</p>

<h1>encoding: UTF-8</h1>

<p>import sys
sys.path.append(&lsquo;/path/to/django/project&rsquo;)
import os
os.environ[&lsquo;DJANGO_SETTINGS_MODULE&rsquo;] = &lsquo;project.settings&rsquo;</p>

<p>from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()</p>

<p>from application.models import AModel</p>

<p>list = AModel.objects.all()
&hellip;
```</p>
]]></content>
  </entry>
  
</feed>
