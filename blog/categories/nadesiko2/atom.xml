<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: なでしこ2 | shigeponが関心のある技術情報など]]></title>
  <link href="http://blog.shigepon.com/blog/categories/nadesiko2/atom.xml" rel="self"/>
  <link href="http://blog.shigepon.com/"/>
  <updated>2014-06-15T21:51:43+09:00</updated>
  <id>http://blog.shigepon.com/</id>
  <author>
    <name><![CDATA[shigepon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[なでしこ2のプラグインを作る方法]]></title>
    <link href="http://blog.shigepon.com/blog/2014/01/29/nadesiko2-make-plugin/"/>
    <updated>2014-01-29T09:49:17+09:00</updated>
    <id>http://blog.shigepon.com/blog/2014/01/29/nadesiko2-make-plugin</id>
    <content type="html"><![CDATA[<p>なでしこ2でプラグインを作りたい人向けというニッチすぎるネタです。現在なでしこの時期バージョンなでしこ2が開発中です(えらい長いこと開発中です)が、構文の実装がある程度終わっているので、プラグインを開発することが出来ます。try catchの実装どうするかなーとか考えて進んでないですが、それはそれ。</p>

<p>なでしこ2はC#で組まれているので、プラグインもC#で組むことができます。</p>

<p>まずは準備として、なでしこ2のソースをsvnでチェックアウトします。 <a href="http://code.google.com/p/nadesiko2/source/checkout">URL</a></p>

<p>SharpDevelopで開発中なので、SharpDevelopでソリューションを開きます。で、中にNakoPluginXXXというプロジェクトがあるので、それを参考にすれば良いわけですが、軽く説明しておきます。</p>

<p>プラグインのソースは下のようになります。</p>

<p>```
/<em>
 * Created by SharpDevelop.
 * User: shigepon
 * Date: 2011/04/04
 * Time: 9:42
 *
 * To change this template use Tools | Options | Coding | Edit Standard Headers.
 </em>/
using System;
using System.Collections.Generic;
using System.Text;
using Libnako.JPNCompiler;
using NakoPlugin;
namespace NakoPluginSample{</p>

<pre><code>public class NakoPluginSample : INakoPlugin    {
string _description = &amp;quot;サンプルプラグイン&amp;quot;;
    double _version = 1.0;
    //&lt;del&gt; プラグイン共通の部分 &lt;/del&gt;
    public double TargetNakoVersion { get { return 2.0; } }
    public bool Used { get; set; }
    public string Name { get { return this.GetType().FullName; } }
    public double PluginVersion { get { return _version; } }
    public string Description { get { return _description; } }
    //&lt;del&gt; 関数の定義 &lt;/del&gt;
    public void DefineFunction(INakoPluginBank bank)        {
        bank.AddFunc({関数名}&amp;cedil; {なでしこ形式の引数}&amp;cedil; {戻り値の形式}&amp;cedil; {実際の呼び出し先}&amp;cedil;{関数の説明}&amp;cedil; {関数のよみかた});
    }
// プラグインの初期化処理
    public void PluginInit(INakoInterpreter runner)        {
    }
    // プラグインの終了処理
    public void PluginFin(INakoInterpreter runner)        {
    }
   public Object {実際の処理}(INakoFuncCallInfo info){
        ...
    }
}
</code></pre>

<p>}
```</p>

<p>実装時に大事なとこを説明します。</p>

<p>+まずプラグイン共通部分とPluginInit、PluginFinはコピペでもかまわないと思います。私もまだ初期処理、終了処理の必要なプラグインは作っていません。
+なでしこ上での関数呼び出し方法の定義はDefineFunctionで行います。bank.AddFuncメソッドで関数を追加できます。メソッド内の引数は下のように設定します。
++関数名はなでしこで呼び出す名前になります。（例：文字検索）なでしこで使う助詞を使わないとか、他の命令の名称とかぶらないなどの制限があります。
++なでしこ形式の引数は「SでAを」のようになでしこで一般的に使う形式で指定します。引数を参照渡しにしたい場合は「{参照渡し}SでAを」のように指定します。助詞を複数指定したい場合は「SでAを|Sが」という形式で指定します。参照渡しを使う場合は実装が少々複雑になります。後日やり方を書こうと思います。
++戻り値の形式はenum NakoVarTypeで指定します。(Void&cedil; Int&cedil; Double&cedil; String&cedil; Array)
++実際の呼び出し先はそのままメソッド名を指定します。(_hogeとか)
++関数の説明と関数のよみかたは分かりやすさの為に必要です。個人用なら適当でも良いと思います。（多分今後エディタとかそういうのにつかわれると思います）
+実際の処理は必ずINakoFuncCallInfo型のインスタンスを引数に取ります。なでしこで渡された引数はこのインスタンスから取得します。取得方法は以下</p>

<p><code>
long l = info.StackPopAsInt();
double d = info.StackPopAsDouble();
String s = info.StackPopAsString();
Object o = info.StackPop();//配列の場合はこれを使う
</code></p>

<p>StackPopメソッドで得られる値はNakoVariable型なので、ちょっと扱いが難しくなります。実際の処理の実装方法はまた今度</p>
]]></content>
  </entry>
  
</feed>
